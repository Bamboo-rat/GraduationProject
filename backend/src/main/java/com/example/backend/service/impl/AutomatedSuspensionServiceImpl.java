package com.example.backend.service.impl;

import com.example.backend.entity.*;
import com.example.backend.entity.enums.*;
import com.example.backend.exception.ErrorCode;
import com.example.backend.exception.custom.NotFoundException;
import com.example.backend.repository.*;
import com.example.backend.service.AutomatedSuspensionService;
import com.example.backend.service.InAppNotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Service implementation for automated customer suspension and violation tracking
 * Uses CustomerDisciplinaryRecord to track violations, warnings, and suspensions
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AutomatedSuspensionServiceImpl implements AutomatedSuspensionService {

    private final CustomerRepository customerRepository;
    private final CustomerDisciplinaryRecordRepository disciplinaryRecordRepository;
    private final AdminRepository adminRepository;
    private final InAppNotificationService notificationService;

    // ========== SPAM/COMMENT VIOLATIONS ==========

    @Override
    @Transactional
    public void checkSpamViolations(String customerId) {
        log.info("Checking spam violations for customer: {}", customerId);

        LocalDateTime oneDayAgo = LocalDateTime.now().minusDays(1);

        // Count comments in last 24 hours
        long commentsLast24h = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.SPAM_COMMENT, oneDayAgo);

        // Count violating comments (all time)
        long violatingComments = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.BANNED_KEYWORD, LocalDateTime.now().minusYears(10));

        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        // Rule 1: >= 5 comments in 24 hours → Warning
        if (commentsLast24h >= 5) {
            long existingWarnings = disciplinaryRecordRepository.countByCustomerUserIdAndActionTakenAndCreatedAtAfter(
                    customerId, ViolationAction.WARNING, oneDayAgo);

            if (existingWarnings == 0) {
                log.warn("Customer {} exceeded comment limit: {} comments in 24h", customerId, commentsLast24h);
                issueWarning(customerId,
                        String.format("Spam warning: %d comments in 24 hours", commentsLast24h),
                        ViolationType.SPAM_COMMENT);
            }
        }

        // Rule 2: >= 10 violating comments → 3-day suspension
        if (violatingComments >= 10) {
            boolean hasRecentSuspension = disciplinaryRecordRepository.countByCustomerUserIdAndActionTakenAndCreatedAtAfter(
                    customerId, ViolationAction.TEMPORARY_SUSPENSION, LocalDateTime.now().minusDays(3)) > 0;

            if (!hasRecentSuspension && customer.getStatus() != CustomerStatus.SUSPENDED) {
                log.warn("Customer {} has {} violating comments - applying 3-day suspension",
                        customerId, violatingComments);
                applySuspension(customerId, 3,
                        String.format("Automated suspension: %d violating comments detected", violatingComments),
                        ViolationType.BANNED_KEYWORD);
            }
            // Rule 3: More violations after suspension → permanent ban
            else if (hasRecentSuspension) {
                log.warn("Customer {} violated again after suspension - applying permanent ban", customerId);
                applyPermanentBan(customerId,
                        "Repeated violations after suspension: spam/banned keywords",
                        ViolationType.BANNED_KEYWORD);
            }
        }
    }

    @Override
    @Transactional
    public void recordComment(String customerId, String commentId, String commentType) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
        record.setCustomer(customer);
        record.setViolationType(ViolationType.SPAM_COMMENT);
        record.setSeverity(ViolationSeverity.LOW);
        record.setDescription("Comment recorded for spam tracking");
        record.setReferenceId(commentId);
        record.setReferenceType(commentType);
        record.setActionTaken(ViolationAction.NO_ACTION);
        record.setAutoGenerated(true);
        record.setResolved(true);

        disciplinaryRecordRepository.save(record);
        log.debug("Recorded comment {} for customer {}", commentId, customerId);
    }

    @Override
    @Transactional
    public void recordViolatingComment(String customerId, String commentId, String reason) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
        record.setCustomer(customer);
        record.setViolationType(ViolationType.BANNED_KEYWORD);
        record.setSeverity(ViolationSeverity.HIGH);
        record.setDescription(reason);
        record.setReferenceId(commentId);
        record.setReferenceType("COMMENT");
        record.setActionTaken(ViolationAction.NO_ACTION);
        record.setAutoGenerated(true);
        record.setResolved(false);

        disciplinaryRecordRepository.save(record);
        log.warn("Recorded violating comment {} for customer {}: {}", commentId, customerId, reason);

        checkSpamViolations(customerId);
    }

    // ========== ORDER CANCELLATION VIOLATIONS ==========

    @Override
    @Transactional
    public void checkCancellationViolations(String customerId) {
        log.info("Checking cancellation violations for customer: {}", customerId);

        LocalDateTime sevenDaysAgo = LocalDateTime.now().minusDays(7);
        LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);
        LocalDateTime sixtyDaysAgo = LocalDateTime.now().minusDays(60);

        long cancellations7Days = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.ORDER_CANCELLATION, sevenDaysAgo);
        long cancellations30Days = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.ORDER_CANCELLATION, thirtyDaysAgo);
        long cancellations60Days = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.ORDER_CANCELLATION, sixtyDaysAgo);

        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        if (cancellations7Days >= 5) {
            long recentWarnings = disciplinaryRecordRepository.countByCustomerUserIdAndActionTakenAndCreatedAtAfter(
                    customerId, ViolationAction.WARNING, sevenDaysAgo);

            if (recentWarnings == 0) {
                log.warn("Customer {} has {} cancellations in 7 days - issuing warning",
                        customerId, cancellations7Days);
                issueWarning(customerId,
                        String.format("Warning: %d order cancellations in 7 days", cancellations7Days),
                        ViolationType.ORDER_CANCELLATION);
            }
        }

        if (cancellations30Days >= 10 && customer.getStatus() != CustomerStatus.SUSPENDED) {
            log.warn("Customer {} has {} cancellations in 30 days - applying 7-day suspension",
                    customerId, cancellations30Days);
            applySuspension(customerId, 7,
                    String.format("Automated suspension: %d order cancellations in 30 days", cancellations30Days),
                    ViolationType.ORDER_CANCELLATION);
        }

        if (cancellations60Days >= 20) {
            log.warn("Customer {} has {} cancellations in 60 days - applying permanent ban",
                    customerId, cancellations60Days);
            applyPermanentBan(customerId,
                    String.format("Excessive order cancellations: %d times in 60 days", cancellations60Days),
                    ViolationType.ORDER_CANCELLATION);
        }
    }

    @Override
    @Transactional
    public void recordOrderCancellation(String customerId, String orderId, boolean customerFault) {
        if (!customerFault) {
            log.debug("Order {} cancelled due to store fault - not recording violation", orderId);
            return;
        }

        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
        record.setCustomer(customer);
        record.setViolationType(ViolationType.ORDER_CANCELLATION);
        record.setSeverity(ViolationSeverity.MEDIUM);
        record.setDescription("Order cancelled by customer");
        record.setReferenceId(orderId);
        record.setReferenceType("ORDER");
        record.setActionTaken(ViolationAction.NO_ACTION);
        record.setAutoGenerated(true);
        record.setResolved(true);

        disciplinaryRecordRepository.save(record);
        log.info("Recorded order cancellation {} for customer {}", orderId, customerId);

        checkCancellationViolations(customerId);
    }

    // ========== COMMUNITY REPORTS ==========

    @Override
    @Transactional
    public void checkCommunityReports(String customerId) {
        log.info("Checking community reports for customer: {}", customerId);

        long confirmedReports = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.COMMUNITY_REPORT, LocalDateTime.now().minusYears(10));

        if (confirmedReports >= 3) {
            Customer customer = customerRepository.findById(customerId)
                    .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

            if (customer.getStatus() != CustomerStatus.SUSPENDED) {
                log.warn("Customer {} has {} confirmed reports - suspending for review",
                        customerId, confirmedReports);

                CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
                record.setCustomer(customer);
                record.setViolationType(ViolationType.COMMUNITY_REPORT);
                record.setSeverity(ViolationSeverity.CRITICAL);
                record.setDescription(String.format("%d confirmed community reports", confirmedReports));
                record.setActionTaken(ViolationAction.UNDER_REVIEW);
                record.setAutoGenerated(true);
                record.setResolved(false);
                disciplinaryRecordRepository.save(record);

                customer.setStatus(CustomerStatus.SUSPENDED);
                customer.setActive(false);
                customerRepository.save(customer);

                try {
                    notificationService.createNotificationForAllAdmins(
                            NotificationType.SYSTEM_ANNOUNCEMENT,
                            String.format("Khách hàng '%s' bị tạm khóa tự động do %d báo cáo từ cộng đồng. Vui lòng xem xét.",
                                    customer.getFullName(), confirmedReports),
                            "/customers/" + customerId
                    );
                } catch (Exception e) {
                    log.error("Failed to notify admins about automatic suspension", e);
                }

                log.info("Customer {} suspended pending admin review", customerId);
            }
        }
    }

    @Override
    @Transactional
    public void recordCommunityReport(String customerId, String reportedBy, String reason, String referenceId) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
        record.setCustomer(customer);
        record.setViolationType(ViolationType.COMMUNITY_REPORT);
        record.setSeverity(ViolationSeverity.HIGH);
        record.setDescription(String.format("Reported by %s: %s", reportedBy, reason));
        record.setReferenceId(referenceId);
        record.setReferenceType("REPORT");
        record.setActionTaken(ViolationAction.NO_ACTION);
        record.setAutoGenerated(false);
        record.setResolved(false);

        disciplinaryRecordRepository.save(record);
        log.warn("Community report recorded for customer {} by {}: {}", customerId, reportedBy, reason);

        checkCommunityReports(customerId);
    }

    // ========== SUSPENSION MANAGEMENT ==========

    @Override
    @Transactional
    public void processExpiredSuspensions() {
        log.info("Processing expired suspensions...");

        LocalDateTime now = LocalDateTime.now();
        List<CustomerDisciplinaryRecord> expiredSuspensions = disciplinaryRecordRepository
                .findExpiredSuspensions(now);

        for (CustomerDisciplinaryRecord record : expiredSuspensions) {
            try {
                Customer customer = record.getCustomer();

                if (customer.getStatus() == CustomerStatus.SUSPENDED) {
                    customer.setStatus(CustomerStatus.ACTIVE);
                    customer.setActive(true);
                    customerRepository.save(customer);

                    record.setReinstatedAt(now);
                    disciplinaryRecordRepository.save(record);

                    log.info("Reinstated customer {} after suspension expiry", customer.getUserId());

                    try {
                        notificationService.createNotificationForUser(
                                customer.getUserId(),
                                NotificationType.SYSTEM_ANNOUNCEMENT,
                                "Tài khoản của bạn đã được khôi phục. Vui lòng tuân thủ chính sách để tránh bị khóa lại.",
                                "/profile"
                        );
                    } catch (Exception e) {
                        log.error("Failed to notify customer about reinstatement", e);
                    }
                }
            } catch (Exception e) {
                log.error("Error processing suspension reinstatement for record {}",
                        record.getRecordId(), e);
            }
        }

        log.info("Processed {} expired suspensions", expiredSuspensions.size());
    }

    @Override
    @Transactional(readOnly = true)
    public ViolationSummary getViolationSummary(String customerId) {
        LocalDateTime now = LocalDateTime.now();

        long totalViolations = disciplinaryRecordRepository.findByCustomerUserIdAndResolvedFalseOrderByCreatedAtDesc(customerId).size();
        long activeWarnings = disciplinaryRecordRepository.countByCustomerUserIdAndActionTakenAndCreatedAtAfter(
                customerId, ViolationAction.WARNING, now.minusDays(30));
        long activeSuspensions = disciplinaryRecordRepository.countByCustomerUserIdAndActionTakenAndCreatedAtAfter(
                customerId, ViolationAction.TEMPORARY_SUSPENSION, now.minusDays(90));
        long permanentBans = disciplinaryRecordRepository.countByCustomerUserIdAndActionTakenAndCreatedAtAfter(
                customerId, ViolationAction.PERMANENT_BAN, now.minusYears(10));

        long spamCount24h = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.SPAM_COMMENT, now.minusDays(1));
        long violatingComments = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.BANNED_KEYWORD, now.minusYears(10));

        long cancellations7Days = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.ORDER_CANCELLATION, now.minusDays(7));
        long cancellations30Days = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.ORDER_CANCELLATION, now.minusDays(30));
        long cancellations60Days = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.ORDER_CANCELLATION, now.minusDays(60));

        long confirmedReports = disciplinaryRecordRepository.countByCustomerUserIdAndViolationTypeAndCreatedAtAfter(
                customerId, ViolationType.COMMUNITY_REPORT, now.minusYears(10));

        List<CustomerDisciplinaryRecord> activeSuspensionRecords = 
                disciplinaryRecordRepository.findCurrentlySuspendedByCustomer(customerId, now);
        boolean isCurrentlySuspended = !activeSuspensionRecords.isEmpty();

        String suspendedUntil = null;
        if (isCurrentlySuspended && !activeSuspensionRecords.isEmpty()) {
            suspendedUntil = activeSuspensionRecords.get(0).getSuspendedUntil().toString();
        }

        return new ViolationSummary(
                totalViolations,
                activeWarnings,
                activeSuspensions,
                permanentBans,
                spamCount24h,
                violatingComments,
                cancellations7Days,
                cancellations30Days,
                cancellations60Days,
                confirmedReports,
                isCurrentlySuspended,
                suspendedUntil
        );
    }

    @Override
    @Transactional
    public void resolveViolation(String violationId, String adminId, String notes) {
        CustomerDisciplinaryRecord record = disciplinaryRecordRepository.findById(violationId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.INVALID_REQUEST, "Violation not found"));

        Admin admin = adminRepository.findById(adminId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        record.setResolved(true);
        record.setReviewedByAdmin(admin);
        record.setAdminNotes(notes);
        record.setReviewedAt(LocalDateTime.now());

        disciplinaryRecordRepository.save(record);
        log.info("Violation {} resolved by admin {}", violationId, adminId);
    }

    @Override
    public boolean shouldAutoSuspend(Customer customer) {
        ViolationSummary summary = getViolationSummary(customer.getUserId());

        return summary.violatingCommentsCount() >= 10 ||
               summary.cancellationsLast30Days() >= 10 ||
               summary.cancellationsLast60Days() >= 20 ||
               summary.confirmedReports() >= 3;
    }

    @Override
    @Transactional
    public void applySuspension(String customerId, int durationDays, String reason, ViolationType violationType) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        LocalDateTime suspendedUntil = LocalDateTime.now().plusDays(durationDays);

        CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
        record.setCustomer(customer);
        record.setViolationType(violationType);
        record.setSeverity(ViolationSeverity.HIGH);
        record.setDescription(reason);
        record.setActionTaken(ViolationAction.TEMPORARY_SUSPENSION);
        record.setSuspendedUntil(suspendedUntil);
        record.setAutoGenerated(true);
        record.setResolved(false);
        record.setPreviousStatus(customer.getStatus());
        record.setNewStatus(CustomerStatus.SUSPENDED);
        record.setSuspensionDurationDays(durationDays);
        
        disciplinaryRecordRepository.save(record);

        customer.setStatus(CustomerStatus.SUSPENDED);
        customer.setActive(false);
        customerRepository.save(customer);

        log.warn("Customer {} suspended for {} days: {}", customerId, durationDays, reason);

        try {
            notificationService.createNotificationForUser(
                    customerId,
                    NotificationType.SYSTEM_ANNOUNCEMENT,
                    String.format("Tài khoản của bạn đã bị tạm khóa %d ngày. Lý do: %s", durationDays, reason),
                    "/profile"
            );
        } catch (Exception e) {
            log.error("Failed to notify customer about suspension", e);
        }
    }

    @Override
    @Transactional
    public void applyPermanentBan(String customerId, String reason, ViolationType violationType) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
        record.setCustomer(customer);
        record.setViolationType(violationType);
        record.setSeverity(ViolationSeverity.CRITICAL);
        record.setDescription(reason);
        record.setActionTaken(ViolationAction.PERMANENT_BAN);
        record.setAutoGenerated(true);
        record.setResolved(false);
        record.setPreviousStatus(customer.getStatus());
        record.setNewStatus(CustomerStatus.BANNED);
        
        disciplinaryRecordRepository.save(record);

        customer.setStatus(CustomerStatus.BANNED);
        customer.setActive(false);
        customerRepository.save(customer);

        log.warn("Customer {} permanently banned: {}", customerId, reason);

        try {
            notificationService.createNotificationForUser(
                    customerId,
                    NotificationType.SYSTEM_ANNOUNCEMENT,
                    String.format("Tài khoản của bạn đã bị cấm vĩnh viễn. Lý do: %s", reason),
                    "/profile"
            );
        } catch (Exception e) {
            log.error("Failed to notify customer about ban", e);
        }

        try {
            notificationService.createNotificationForAllAdmins(
                    NotificationType.SYSTEM_ANNOUNCEMENT,
                    String.format("Khách hàng '%s' đã bị cấm vĩnh viễn tự động. Lý do: %s",
                            customer.getFullName(), reason),
                    "/customers/" + customerId
            );
        } catch (Exception e) {
            log.error("Failed to notify admins about ban", e);
        }
    }

    @Override
    @Transactional
    public void issueWarning(String customerId, String reason, ViolationType violationType) {
        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new NotFoundException(ErrorCode.USER_NOT_FOUND));

        CustomerDisciplinaryRecord record = new CustomerDisciplinaryRecord();
        record.setCustomer(customer);
        record.setViolationType(violationType);
        record.setSeverity(ViolationSeverity.MEDIUM);
        record.setDescription(reason);
        record.setActionTaken(ViolationAction.WARNING);
        record.setAutoGenerated(true);
        record.setResolved(false);
        disciplinaryRecordRepository.save(record);

        log.info("Warning issued to customer {}: {}", customerId, reason);

        try {
            notificationService.createNotificationForUser(
                    customerId,
                    NotificationType.SYSTEM_ANNOUNCEMENT,
                    String.format("Cảnh báo: %s. Vui lòng tuân thủ chính sách để tránh bị khóa tài khoản.", reason),
                    "/profile"
            );
        } catch (Exception e) {
            log.error("Failed to notify customer about warning", e);
        }
    }
}
