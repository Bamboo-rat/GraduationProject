# üîß Store Inventory Synchronization Fix

## üìã Problem Summary

**Issue:** When creating products through the supplier portal, store inventory quantities were collected in the form but **never saved to the database**.

**Root Cause:** Frontend was sending an empty `storeInventory` array because of a **SKU chicken-and-egg problem**:
- Backend expects `variantSku` in the `StoreInventoryRequest`
- Frontend can't provide SKU because SKUs are auto-generated by backend during product creation
- Frontend used temporary keys like `"storeId-variantIndex"` but had no way to map them to actual SKUs
- Solution was commented as "Backend auto-generates SKUs" and sent empty array

---

## ‚úÖ Solution Implemented

### **Approach: Variant Index Support**

Modified the backend to accept **variant index** (position in variants array) in addition to SKU, allowing frontend to specify inventory by variant position during creation.

---

## üî® Changes Made

### **1. Backend DTO Update**

**File:** `backend/src/main/java/com/example/backend/dto/request/StoreInventoryRequest.java`

**Changes:**
- Made `variantSku` optional (for updates)
- Added `variantIndex` field (for creation)

```java
@Data
public class StoreInventoryRequest {
    @NotBlank(message = "Store ID is required")
    private String storeId;

    // For updates: use existing variant SKU
    private String variantSku;

    // For creation: use variant index (position in variants array)
    @Min(value = 0, message = "Variant index must be at least 0")
    private Integer variantIndex;

    @Min(value = 0, message = "Stock quantity must be at least 0")
    private int stockQuantity;

    private BigDecimal priceOverride;
}
```

---

### **2. Backend Service Logic Update**

**File:** `backend/src/main/java/com/example/backend/service/impl/ProductServiceImpl.java`

**Changes:**
Modified the inventory creation logic in `createProduct()` method (lines 132-177):

**New Logic:**
1. ‚úÖ Check if `variantSku` is provided ‚Üí Use SKU to find variant (for updates)
2. ‚úÖ If not, check if `variantIndex` is provided ‚Üí Use index to get variant from list
3. ‚úÖ Validate index is within bounds
4. ‚úÖ Create `StoreProduct` entry with proper variant reference
5. ‚úÖ Log detailed information for debugging

```java
// Support both SKU (for updates) and index (for creation)
if (invReq.getVariantSku() != null && !invReq.getVariantSku().isBlank()) {
    // Use SKU to find variant
    variant = persistedVariantMap.get(invReq.getVariantSku());
} else if (invReq.getVariantIndex() != null) {
    // Use index to get variant from the ordered list
    List<ProductVariant> variantList = new ArrayList<>(product.getVariants());
    if (invReq.getVariantIndex() >= 0 && invReq.getVariantIndex() < variantList.size()) {
        variant = variantList.get(invReq.getVariantIndex());
        log.debug("Found variant by index {}: {}", invReq.getVariantIndex(), variant.getSku());
    } else {
        log.warn("Variant index {} out of bounds. Skipping inventory creation.", invReq.getVariantIndex());
        continue;
    }
}
```

---

### **3. Frontend Type Update**

**File:** `website/fe_supplier/app/service/productService.ts`

**Changes:**
Updated interface to match backend:

```typescript
export interface StoreInventoryRequest {
  storeId: string;
  variantSku?: string;      // For updates: use existing variant SKU
  variantIndex?: number;    // For creation: use variant index (position in variants array)
  stockQuantity: number;
  priceOverride?: number;
}
```

---

### **4. Frontend Submission Fix**

**File:** `website/fe_supplier/app/pages/products/CreateProduct.tsx`

**Changes:**
Fixed `handleSubmit()` function (lines 715-757) to properly convert inventory data:

**Before:**
```typescript
storeInventory: [], // ‚ùå Empty array - data lost!
```

**After:**
```typescript
// Convert storeInventory to use variant indices instead of temporary SKUs
const storeInventoryWithIndices = storeInventory.map((inv) => {
  // Extract variant index from the temporary key: "storeId-variantIndex"
  const variantIndex = parseInt(inv.variantSku?.split('-').pop() || '0');
  return {
    storeId: inv.storeId,
    variantIndex: variantIndex, // Use index instead of SKU
    stockQuantity: inv.stockQuantity,
    priceOverride: inv.priceOverride,
  };
});

const request: CreateProductRequest = {
  product: productInfo,
  attributes: attributes.filter((a) => a.attributeName && a.attributeValue),
  variants: variantsWithImages,
  images: productImages,
  storeInventory: storeInventoryWithIndices, // ‚úÖ Send actual inventory data
};
```

---

## üéØ How It Works Now

### **Product Creation Flow:**

1. **Frontend:** User fills out product form including store inventory
2. **Frontend:** Collects inventory with temporary keys like `"storeId-0"`, `"storeId-1"`
3. **Frontend:** On submit, extracts variant index from temporary key
4. **Frontend:** Sends request with `variantIndex` field:
   ```json
   {
     "storeInventory": [
       {
         "storeId": "store-123",
         "variantIndex": 0,
         "stockQuantity": 50
       },
       {
         "storeId": "store-123",
         "variantIndex": 1,
         "stockQuantity": 30
       }
     ]
   }
   ```
5. **Backend:** Receives request, creates product and variants
6. **Backend:** For each inventory item, looks up variant by index
7. **Backend:** Creates `StoreProduct` entries with correct variant references
8. **Backend:** Saves everything in single transaction
9. **Backend:** Returns complete product with inventory data

---

## üìä Example Request/Response

### **Frontend Sends:**
```json
{
  "product": {
    "name": "N∆∞·ªõc Gi·∫∑t Comfort",
    "description": "H∆∞∆°ng hoa anh ƒë√†o",
    "categoryId": "cat-123"
  },
  "variants": [
    {
      "name": "Chai 1.8L",
      "originalPrice": 95000,
      "discountPrice": 80000,
      "expiryDate": "2025-12-31"
    },
    {
      "name": "Chai 3.6L",
      "originalPrice": 180000,
      "discountPrice": 150000,
      "expiryDate": "2025-12-31"
    }
  ],
  "storeInventory": [
    {
      "storeId": "store-1",
      "variantIndex": 0,
      "stockQuantity": 50
    },
    {
      "storeId": "store-1",
      "variantIndex": 1,
      "stockQuantity": 30
    },
    {
      "storeId": "store-2",
      "variantIndex": 0,
      "stockQuantity": 20
    }
  ]
}
```

### **Backend Creates:**
```
Product: "N∆∞·ªõc Gi·∫∑t Comfort"
‚îú‚îÄ Variant[0]: "Chai 1.8L" (SKU: SUP0403-NGCDV-C18L-1234)
‚îÇ  ‚îú‚îÄ StoreProduct: Store 1, Stock: 50
‚îÇ  ‚îî‚îÄ StoreProduct: Store 2, Stock: 20
‚îî‚îÄ Variant[1]: "Chai 3.6L" (SKU: SUP0403-NGCDV-C36L-5678)
   ‚îî‚îÄ StoreProduct: Store 1, Stock: 30
```

---

## ‚ú® Benefits

### **1. Single Transaction**
‚úÖ All data saved atomically - no partial failures

### **2. Better Performance**
‚úÖ One API call instead of multiple updates

### **3. Data Consistency**
‚úÖ Product and inventory created together

### **4. Cleaner Code**
‚úÖ No complex error handling for partial failures

### **5. Backward Compatible**
‚úÖ Stock update API still works with SKU for editing existing products

---

## üß™ Testing Instructions

### **Manual Test:**

1. **Start Backend:**
   ```bash
   cd backend
   ./run.ps1  # Windows
   # or
   mvn spring-boot:run
   ```

2. **Start Frontend:**
   ```bash
   cd website/fe_supplier
   npm install
   npm run dev
   ```

3. **Test Product Creation:**
   - Login as supplier
   - Navigate to Products ‚Üí Create Product
   - Fill in product info
   - Add 2-3 variants
   - In "T·ªìn kho t·∫°i c·ª≠a h√†ng" section, add quantities for each store
   - Submit form

4. **Verify:**
   - Check backend logs for: `"Added inventory for variant ... at store ..."`
   - Query database:
     ```sql
     SELECT p.name, v.name, v.sku, s.store_name, sp.stock_quantity
     FROM products p
     JOIN product_variants v ON v.product_id = p.product_id
     JOIN store_products sp ON sp.variant_id = v.variant_id
     JOIN stores s ON s.store_id = sp.store_id
     WHERE p.name = 'YOUR_PRODUCT_NAME';
     ```
   - Should see inventory entries for each variant at each store

---

## üö® Important Notes

### **Variant Order Preservation:**
- ‚ö†Ô∏è Variant index depends on the order in the `variants` array
- ‚ö†Ô∏è Frontend must maintain consistent ordering
- ‚úÖ Currently safe because variants are added sequentially

### **Validation:**
- ‚úÖ Backend validates index is within bounds
- ‚úÖ Skips invalid entries with warning logs
- ‚úÖ Continues processing other valid entries

### **Error Handling:**
- ‚úÖ Invalid index ‚Üí Warning logged, entry skipped
- ‚úÖ Store not found ‚Üí Exception thrown, transaction rolled back
- ‚úÖ Neither SKU nor index provided ‚Üí Warning logged, entry skipped

---

## üîÆ Future Enhancements

### **Potential Improvements:**

1. **Bulk Inventory Import**
   - CSV upload for initial stock
   - Excel template support

2. **Inventory Validation**
   - Warn if total inventory is very low
   - Suggest minimum stock levels

3. **Default Stock Values**
   - Remember last used values
   - Quick "Copy from previous product"

4. **Inventory Preview**
   - Show summary before submit
   - Visual confirmation of what will be saved

---

## üìù Files Modified

### **Backend:**
1. ‚úÖ `dto/request/StoreInventoryRequest.java` - Added variantIndex field
2. ‚úÖ `service/impl/ProductServiceImpl.java` - Updated inventory creation logic

### **Frontend:**
1. ‚úÖ `service/productService.ts` - Updated interface
2. ‚úÖ `pages/products/CreateProduct.tsx` - Fixed submission logic

### **Documentation:**
1. ‚úÖ `docs/STORE_INVENTORY_FIX.md` - This file

---

## ‚úÖ Verification Checklist

- [x] Backend DTO updated with variantIndex
- [x] Backend service handles both SKU and index
- [x] Frontend interface updated
- [x] Frontend submission sends inventory data
- [x] Backward compatible with stock update API
- [x] Proper validation and error handling
- [x] Detailed logging for debugging
- [x] Documentation created

---

## üéâ Status

**‚úÖ IMPLEMENTATION COMPLETE**

The store inventory synchronization issue has been resolved. Products created through the supplier portal will now properly save inventory quantities to the database.

**Next Steps:**
1. Build and test the backend
2. Test product creation with various scenarios
3. Verify database entries are correct
4. Test edge cases (invalid indices, missing stores, etc.)

---

*Date: October 31, 2025*
*Issue: Store inventory not saved during product creation*
*Solution: Support variant index in addition to SKU*
*Status: Ready for Testing*
